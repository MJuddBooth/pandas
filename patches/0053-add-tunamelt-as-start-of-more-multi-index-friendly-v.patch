From 6c159cca141e1ba11a32d7e3e2dad95cda35bd6f Mon Sep 17 00:00:00 2001
From: Michael Booth <m.judd.booth@gmail.com>
Date: Wed, 2 Jul 2014 04:28:06 -0400
Subject: [PATCH 0053/1009] add tunamelt as start of more multi-index friendly
 version of melt.

---
 pandas/core/reshape.py | 152 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 152 insertions(+)

diff --git a/pandas/core/reshape.py b/pandas/core/reshape.py
index e1712be..a9a1829 100644
--- a/pandas/core/reshape.py
+++ b/pandas/core/reshape.py
@@ -770,6 +770,158 @@ def melt(frame, id_vars=None, value_vars=None,
 
     return DataFrame(mdata, columns=mcolumns)
 
+def tunamelt(frame, id_vars=None, value_vars=None,
+         var_name=None, value_name='value', col_level=None):
+    """
+    "Unpivots" a DataFrame from wide format to long format, optionally leaving
+    identifier variables set.
+
+    This function is useful to massage a DataFrame into a format where one
+    or more columns are identifier variables (`id_vars`), while all other
+    columns, considered measured variables (`value_vars`), are "unpivoted" to
+    the row axis, leaving just two non-identifier columns, 'variable' and
+    'value'.
+
+    Parameters
+    ----------
+    frame : DataFrame
+    id_vars : tuple, list, or ndarray, optional
+        Column(s) to use as identifier variables.
+    value_vars : tuple, list, or ndarray, optional
+        Column(s) to unpivot. If not specified, uses all columns that
+        are not set as `id_vars`.
+    var_name : scalar
+        Name to use for the 'variable' column. If None it uses
+        ``frame.columns.name`` or 'variable'.
+    value_name : scalar, default 'value'
+        Name to use for the 'value' column.
+    col_level : int or string, optional
+        If columns are a MultiIndex then use this level to melt.
+
+    See also
+    --------
+    pivot_table
+    DataFrame.pivot
+
+    Examples
+    --------
+    >>> import pandas as pd
+    >>> df = pd.DataFrame({'A': {0: 'a', 1: 'b', 2: 'c'},
+    ...                    'B': {0: 1, 1: 3, 2: 5},
+    ...                    'C': {0: 2, 1: 4, 2: 6}})
+    >>> df
+       A  B  C
+    0  a  1  2
+    1  b  3  4
+    2  c  5  6
+
+    >>> pd.melt(df, id_vars=['A'], value_vars=['B'])
+       A variable  value
+    0  a        B      1
+    1  b        B      3
+    2  c        B      5
+
+    >>> pd.melt(df, id_vars=['A'], value_vars=['B', 'C'])
+       A variable  value
+    0  a        B      1
+    1  b        B      3
+    2  c        B      5
+    3  a        C      2
+    4  b        C      4
+    5  c        C      6
+
+    The names of 'variable' and 'value' columns can be customized:
+
+    >>> pd.melt(df, id_vars=['A'], value_vars=['B'],
+    ...         var_name='myVarname', value_name='myValname')
+       A myVarname  myValname
+    0  a         B          1
+    1  b         B          3
+    2  c         B          5
+
+    If you have multi-index columns:
+
+    >>> df.columns = [list('ABC'), list('DEF')]
+    >>> df
+       A  B  C
+       D  E  F
+    0  a  1  2
+    1  b  3  4
+    2  c  5  6
+
+    >>> pd.melt(df, col_level=0, id_vars=['A'], value_vars=['B'])
+       A variable  value
+    0  a        B      1
+    1  b        B      3
+    2  c        B      5
+
+    >>> pd.melt(df, id_vars=[('A', 'D')], value_vars=[('B', 'E')])
+      (A, D) variable_0 variable_1  value
+    0      a          B          E      1
+    1      b          B          E      3
+    2      c          B          E      5
+
+    """
+    # TODO: what about the existing index?
+    if id_vars is not None:
+        if not isinstance(id_vars, (tuple, list, np.ndarray)):
+            id_vars = [id_vars]
+        else:
+            id_vars = list(id_vars)
+    else:
+        id_vars = []
+
+    if value_vars is not None:
+        if not isinstance(value_vars, (tuple, list, np.ndarray)):
+            value_vars = [value_vars]
+        frame = frame.ix[:, id_vars + value_vars]
+    else:
+        frame = frame.copy()
+
+    if col_level is not None:  # allow list or other?
+        # frame is a copy
+        frame.columns = frame.columns.get_level_values(col_level)
+
+    if var_name is None:
+        if isinstance(frame.columns, MultiIndex):
+            if len(frame.columns.names) == len(set(frame.columns.names)):
+                var_name = frame.columns.names
+            else:
+                var_name = ['variable_%s' % i for i in
+                            range(len(frame.columns.names))]
+        else:
+            var_name = [frame.columns.name if frame.columns.name is not None
+                        else 'variable']
+    if isinstance(var_name, compat.string_types):
+        var_name = [var_name]
+
+    N, K = frame.shape
+    K -= len(id_vars)
+
+    mdata = {}
+ #   for col in id_vars:
+ #       mdata[col] = np.tile(frame.pop(col).values, K)
+
+    idframe = frame[id_vars]
+    idframe = DataFrame(np.tile(idframe.values, (K, 1)), columns=idframe.columns)
+
+    mcolumns = id_vars + var_name + [value_name]
+    datacolumns = var_name + [value_name]
+
+    # can't make this work
+    # frame.drop(id_vars, axis=1, inplace=True)
+    for col in id_vars:
+        frame.pop(col)
+
+#    frame = frame.dro
+    mdata[value_name] = frame.values.ravel('F')
+    for i, col in enumerate(var_name):
+        # asanyarray will keep the columns as an Index
+        mdata[col] = np.asanyarray(frame.columns.get_level_values(i)).repeat(N)
+    dataframe = DataFrame(mdata, columns=datacolumns)
+    newdf     = idframe.join(dataframe)
+    
+    return idframe.join(dataframe)
 
 def lreshape(data, groups, dropna=True, label=None):
     """
-- 
2.6.0

